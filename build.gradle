/*
 * This file was generated by the Gradle 'init' task.
 *
 * This is a general purpose Gradle build.
 * Learn how to create Gradle builds at https://guides.gradle.org/creating-new-gradle-builds
 */

import java.text.SimpleDateFormat
import static java.time.temporal.ChronoUnit.DAYS

plugins {
    // Apply the groovy plugin to add support for Groovy
    id 'groovy'

    // Apply the application plugin to add support for building a CLI application.
    id 'application'

    id "io.github.http-builder-ng.http-plugin" version "0.1.1"
}

repositories {
    // Use jcenter for resolving dependencies.
    // You can declare any Maven/Ivy/file repository here.
    jcenter()
}

dependencies {
    // Use the latest Groovy version for building this library
    implementation 'org.codehaus.groovy:groovy-all:2.5.10'

    // Use the awesome Spock testing and specification framework
    testImplementation 'org.spockframework:spock-core:1.3-groovy-2.5'
}

application {
    // Define the main class for the application.
    mainClassName = 'demo.gradle.App'
}

/**
* Main task to be process and check
*
* This task always returns immediately
*/
task weatherForecast(type: io.github.httpbuilderng.http.HttpTask) {
    // Declare variable to be used for this task
    def city, day, API_KEY

    // Setup Configuration for httpbuilderng.http
    config {
        request.uri = 'https://api.openweathermap.org/data/2.5/forecast'
    }

    if (checkCity()) {
        city = capitalizeFirstLetter(project.property('city'))
    }

    if (checkDay()) {
        day = project.property('day')
    }

    // Throw an error when both city and day properies is not provided
    if (!city && !day) {
        throw new GradleException('City and Day not provided!')
    }


    // Check for Opean Weather API Key
    file('.env').readLines().each {
        def (key, value) = it.tokenize('=')

        if (key == 'API_KEY') {
            API_KEY = value
        }
    }

    post {
        request.uri.query = [
            q: project.property('city'),
            units: 'metric', // Default Units
            appid: API_KEY // Default API KEY
        ]

        response.success { fs, data ->
            // Start to forecast for the given input when get success response from the server
            if (!day) {
                upComingDayWeatherForecast(data)
            } else {
                dayWeatherForecast(data)
            }

        }

        // Print fail message from server if the server return any error during the process
        response.failure { a, b ->
            println b.message
        }
    }
}


/**
* Process the data provided to show the user the 5 upcoming
* weather forcast and details.
*
* This method always returns immediately
*
* @param array the list of data provided by the response from OpenWeather API
*/
void upComingDayWeatherForecast (data) {
    def dayMapped = [:]

    data.list.each {
        // Assuming we're using Unified Time Coordinate, we will format all the time from dt_txt to UTC
        def fullDate = new SimpleDateFormat('yyyy-MM-dd HH:mm:ss').parse(it.get('dt_txt'))
        def dateDay = new SimpleDateFormat('EEEE, MMM d').format(fullDate)

        if (dayMapped.containsKey(dateDay)) {
            dayMapped[dateDay].add(it)
        } else {
            dayMapped.put(dateDay, [it])
        }
    }

    if (dayMapped.size() > 5) {
        dayMapped = dayMapped.take(dayMapped.size() - 1)
    }

    println "Weather for ${city}"

    dayMapped.each { key, value ->
        def weather

        def filteredForecast = value.findAll {
            def fullDate = new SimpleDateFormat('yyyy-MM-dd HH:mm:ss').parse(it.get('dt_txt'))

            return fullDate.getHours() == 12
        }

        if (filteredForecast) {
            weather = filteredForecast.weather[0].main[0]
        } else {
            weather = value[value.size() - 1].weather[0].main[0]
        }

        println ''
        println "* ${key}. Main: ${weather}"
    }
}

/**
* Process the data provided to show the user the choosen date
* weather forcast and details.
*
* This method always returns immediately
*
* @param array the list of data provided by the response from OpenWeather API
*/
void dayWeatherForecast (data) {
    def dayMapped = [:]

    data.list.each {
        // Assuming we're using Unified Time Coordinate, we will format all the time from dt_txt to UTC
        def fullDate = new SimpleDateFormat('yyyy-MM-dd HH:mm:ss').parse(it.get('dt_txt'))
        def dateDay = new SimpleDateFormat('EEEE').format(fullDate)

        if (dayMapped.containsKey(dateDay)) {
            dayMapped[dateDay].add(it)
        } else {
            dayMapped.put(dateDay, [it])
        }
    }

    if (dayMapped[day]) {
        def filteredForecast

        filteredForecast = dayMapped[day].findAll {
            def fullDate = new SimpleDateFormat('yyyy-MM-dd HH:mm:ss').parse(it.get('dt_txt'))

            return fullDate.getHours() == 12
        }

        if (!filteredForecast) {
            filteredForecast = [dayMapped[day].last()]
        }

        def fullDate = new SimpleDateFormat('yyyy-MM-dd HH:mm:ss').parse(filteredForecast[0].get('dt_txt'))
        def dateDay = new SimpleDateFormat('EEEE, MMM d').format(fullDate)

        // Collection of data to be shown
        def weather = filteredForecast.weather[0].main[0]
        def minTemp = filteredForecast.main[0].temp_min
        def maxTemp = filteredForecast.main[0].temp_max
        def humidity = filteredForecast.main[0].humidity

        println "Weather for ${city} ${dateDay}:"
        println ''
        println "* Main: ${weather}"
        println ''
        println "* Min temp: ${minTemp} Celcius degress"
        println ''
        println "* Max temp: ${maxTemp} Celcius degress"
        println ''
        println "* Humidity: ${humidity}"

    } else {
        println "Cannot get data on selected day"
    }
}

/**
* Returns the capitalize the first character for each string
* This method always returns immediately
*
* @param string the string to be capitalize
* @return       string that have been capitalize for each word
*/
def String capitalizeFirstLetter (String string) {
    char[] chars = string.toLowerCase().toCharArray();
    boolean found = false;

    for (int i = 0; i < chars.length; i++) {
        if (!found && Character.isLetter(chars[i])) {
            chars[i] = Character.toUpperCase(chars[i]);
            found = true;
        } else if (Character.isWhitespace(chars[i]) || chars[i]=='.' || chars[i]=='\'') {
            found = false;
        }
    }

    return String.valueOf(chars);
}

/**
* Returns the truthy of property city from user
* This method always returns immediately
*/
def boolean checkCity () {
    return project.hasProperty('city') ? true : false
}


/**
* Returns the truthy of property day from user
* This method always returns immediately
*/
def boolean checkDay () {
    return project.hasProperty('day') ? true : false
}